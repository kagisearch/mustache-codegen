package main

import (
	"bytes"
	"fmt"
	gofmt "go/format"
	"slices"
	"strconv"
	"strings"
	"unicode"
)

const supportImportPath = "github.com/kagisearch/mustache-codegen/go/mustache"

func compileGo(packageName string, templateName string, source string, load func(name string) (string, error)) ([]byte, error) {
	tags, err := parse(string(source))
	if err != nil {
		return nil, err
	}

	var partials [][]tag
	partialFuncNames := make(map[string]string)

	var gatherPartials func(tags []tag) error
	gatherPartials = func(tags []tag) error {
		for t := range walkTags(tags) {
			if t.tt == partial || t.tt == parent {
				if partialFuncNames[t.s] != "" {
					continue
				}
				source, err := load(t.s)
				if err != nil {
					return err
				}
				partialTags, err := parse(source)
				if err != nil {
					return fmt.Errorf("partial %s: %v", t.s, err)
				}

				i := slices.IndexFunc(partials, func(p []tag) bool {
					return slices.EqualFunc(partialTags, p, tagsEqual)
				})
				if i == -1 {
					partials = append(partials, partialTags)
					i = len(partials) - 1
				}
				partialFuncNames[t.s] = fmt.Sprintf("_%s_p%d", templateName, i)
				if err := gatherPartials(partialTags); err != nil {
					return err
				}
			}
		}
		return nil
	}
	if err := gatherPartials(tags); err != nil {
		return nil, err
	}

	buf := new(bytes.Buffer)
	fmt.Fprintln(buf, "// Code generated by mustache-codegen. DO NOT EDIT.")
	fmt.Fprintln(buf)
	fmt.Fprintf(buf, "package %s\n", packageName)
	fmt.Fprintln(buf, "import (")
	fmt.Fprintln(buf, "\t\"html\"")
	fmt.Fprintln(buf, "\t\"reflect\"")
	fmt.Fprintln(buf, "\t\"strings\"")
	fmt.Fprintln(buf)
	fmt.Fprintf(buf, "\tm %q\n", supportImportPath)
	fmt.Fprintln(buf, ")")

	fmt.Fprintln(buf, "// Ignore unused imports.")
	fmt.Fprintln(buf, "var (")
	fmt.Fprintln(buf, "\t_ = html.EscapeString")
	fmt.Fprintln(buf, "\t_ = reflect.ValueOf")
	fmt.Fprintln(buf, "\t_ = m.Lookup")
	fmt.Fprintln(buf, ")")

	for i, partialTags := range partials {
		fmt.Fprintf(buf, "func _%s_p%d(sb *strings.Builder, indent string, stack []reflect.Value, blocks map[string]func(*strings.Builder, string, []reflect.Value)) {\n", templateName, i)
		for _, t := range partialTags {
			if err := compileTagGo(buf, t, partialFuncNames, true, true); err != nil {
				return nil, err
			}
		}
		fmt.Fprintln(buf, "}")
	}

	fmt.Fprintf(buf, "func %s(sb *strings.Builder, data any) {\n", lowerSnakeToUpperCamel(templateName))
	fmt.Fprintln(buf, "\tstack := []reflect.Value{reflect.ValueOf(data)}")
	fmt.Fprintln(buf, "\t_ = stack")
	for _, t := range tags {
		if err := compileTagGo(buf, t, partialFuncNames, false, false); err != nil {
			return nil, err
		}
	}
	fmt.Fprintln(buf, "}")

	formatted, err := gofmt.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}
	return formatted, nil
}

func compileTagGo(buf *bytes.Buffer, t tag, partialFuncNames map[string]string, blocks, indent bool) error {
	switch t.tt {
	case literal:
		fmt.Fprintf(buf, "\tsb.WriteString(%q)\n", t.s)
	case indentPoint:
		if indent {
			fmt.Fprintln(buf, "\tsb.WriteString(indent)")
		}
	case variable:
		fmt.Fprintf(buf, "\tsb.WriteString(html.EscapeString(m.ToString(m.Lookup(stack, %q))))\n", t.s)
	case rawVariable:
		fmt.Fprintf(buf, "\tsb.WriteString(m.ToString(m.Lookup(stack, %q)))\n", t.s)
	case section:
		fmt.Fprintf(buf, "\tfor e := range m.ForEach(m.Lookup(stack, %q)) {\n", t.s)
		fmt.Fprintln(buf, "\t\tstack = append(stack, e)")
		for _, tag := range t.body {
			if err := compileTagGo(buf, tag, partialFuncNames, blocks, indent); err != nil {
				return err
			}
		}
		fmt.Fprintln(buf, "\t\tclear(stack[len(stack)-1:])")
		fmt.Fprintln(buf, "\t\tstack = stack[:len(stack)-1]")
		fmt.Fprintln(buf, "\t}")
	case invertedSection:
		fmt.Fprintf(buf, "\tif m.IsFalsyOrEmptyList(m.Lookup(stack, %q)) {\n", t.s)
		for _, sub := range t.body {
			if err := compileTagGo(buf, sub, partialFuncNames, blocks, indent); err != nil {
				return err
			}
		}
		fmt.Fprintln(buf, "\t}")
	case partial:
		fmt.Fprintf(buf, "\t%s(sb, %s, stack, nil)\n", partialFuncNames[t.s], goIncreaseIndent(indent, t.indent))
	case block:
		if blocks {
			fmt.Fprintf(buf, "\tif b, ok := blocks[%q]; ok {\n", t.s)
			fmt.Fprintf(buf, "\t\tb(sb, %s, stack)\n", goIncreaseIndent(indent, t.indent))
			fmt.Fprintln(buf, "\t} else {")
		}
		for _, sub := range t.body {
			if err := compileTagGo(buf, sub, partialFuncNames, blocks, indent); err != nil {
				return err
			}
		}
		if blocks {
			fmt.Fprintln(buf, "\t}")
		}
	case parent:
		fmt.Fprintln(buf, "\t{")
		fmt.Fprintln(buf, "\t\tpartialBlocks := make(map[string]func(*strings.Builder, string, []reflect.Value))")
		fmt.Fprintln(buf, "\t\t_ = partialBlocks")
		for _, blockTag := range t.body {
			if blockTag.tt != block {
				continue
			}
			fmt.Fprintf(buf, "\t\tpartialBlocks[%q] = func(sb *strings.Builder, indent string, stack []reflect.Value) {\n", blockTag.s)
			for _, blockSub := range blockTag.body {
				if err := compileTagGo(buf, blockSub, partialFuncNames, blocks, true); err != nil {
					return err
				}
			}
			fmt.Fprintln(buf, "\t\t}")
		}
		if blocks {
			fmt.Fprintln(buf, "\t\tfor k, v := range blocks {")
			fmt.Fprintln(buf, "\t\t\tpartialBlocks[k] = v")
			fmt.Fprintln(buf, "\t\t}")
		}
		fmt.Fprintf(buf, "\t\t%s(sb, %s, stack, partialBlocks)\n", partialFuncNames[t.s], goIncreaseIndent(indent, t.indent))
		fmt.Fprintln(buf, "\t}")
	default:
		return fmt.Errorf("unhandled tag %d", t.tt)
	}
	return nil
}

func lowerSnakeToUpperCamel(s string) string {
	sb := new(strings.Builder)
	capitalize := true
	for _, c := range s {
		if capitalize {
			sb.WriteRune(unicode.ToUpper(c))
			capitalize = false
		} else if c == '_' {
			capitalize = true
		} else {
			sb.WriteRune(c)
		}
	}
	return sb.String()
}

func goIndentArg(indent bool) string {
	if indent {
		return "indent"
	} else {
		return `""`
	}
}

func goIncreaseIndent(indentVar bool, indent string) string {
	switch {
	case indentVar && indent == "":
		return "indent"
	case !indentVar:
		return strconv.Quote(indent)
	default:
		return "indent+" + strconv.Quote(indent)
	}
}
